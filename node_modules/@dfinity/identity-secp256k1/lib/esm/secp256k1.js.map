{"version":3,"file":"secp256k1.js","sourceRoot":"","sources":["../../src/secp256k1.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { DerEncodedPublicKey, KeyPair, Signature } from '@dfinity/agent';\nimport Secp256k1 from 'secp256k1';\nimport { sha256 } from 'js-sha256';\nimport { randomBytes } from 'tweetnacl';\nimport hdkey from './hdkey';\nimport { mnemonicToSeedSync } from 'bip39';\nimport { PublicKey, SignIdentity } from '@dfinity/agent';\nimport { fromHexString, toHexString } from './buffer';\nimport { SECP256K1_OID, unwrapDER, wrapDER } from './der';\n\ndeclare type PublicKeyHex = string;\ndeclare type SecretKeyHex = string;\nexport declare type JsonableSecp256k1Identity = [PublicKeyHex, SecretKeyHex];\n\nexport class Secp256k1PublicKey implements PublicKey {\n  /**\n   * Construct Secp256k1PublicKey from an existing PublicKey\n   * @param {PublicKey} key\n   * @returns {Secp256k1PublicKey} Instance of Secp256k1PublicKey\n   */\n  public static from(key: PublicKey): Secp256k1PublicKey {\n    return this.fromDer(key.toDer());\n  }\n\n  public static fromRaw(rawKey: ArrayBuffer): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(this.derDecode(derKey));\n  }\n\n  private static derEncode(publicKey: ArrayBuffer): DerEncodedPublicKey {\n    return wrapDER(publicKey, SECP256K1_OID).buffer as DerEncodedPublicKey;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): ArrayBuffer {\n    return unwrapDER(key, SECP256K1_OID);\n  }\n\n  private readonly rawKey: ArrayBuffer;\n\n  private readonly derKey: DerEncodedPublicKey;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: ArrayBuffer) {\n    key.byteLength;\n    this.rawKey = key;\n    this.derKey = Secp256k1PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): ArrayBuffer {\n    return this.rawKey;\n  }\n}\n\nexport class Secp256k1KeyIdentity extends SignIdentity {\n  /**\n   * Generates an identity. If a seed is provided, the keys are generated from the\n   * seed according to BIP 0032. Otherwise, the key pair is randomly generated.\n   * This method throws an error in case the seed is not 32 bytes long or invalid\n   * for use as a private key.\n   * @param {Uint8Array} seed the optional seed\n   * @returns {Secp256k1KeyIdentity}\n   */\n  public static generate(seed?: Uint8Array): Secp256k1KeyIdentity {\n    if (seed && seed.byteLength !== 32) {\n      throw new Error('Secp256k1 Seed needs to be 32 bytes long.');\n    }\n    let privateKey: Uint8Array;\n\n    if (seed) {\n      // private key from seed according to https://en.bitcoin.it/wiki/BIP_0032\n      // master key generation:\n      privateKey = seed;\n      if (!Secp256k1.privateKeyVerify(privateKey)) {\n        throw new Error('The seed is invalid.');\n      }\n    } else {\n      privateKey = new Uint8Array(randomBytes(32));\n      while (!Secp256k1.privateKeyVerify(privateKey)) {\n        privateKey = new Uint8Array(randomBytes(32));\n      }\n    }\n\n    const publicKeyRaw = Secp256k1.publicKeyCreate(privateKey, false);\n\n    const publicKey = Secp256k1PublicKey.fromRaw(publicKeyRaw);\n    return new this(publicKey, privateKey);\n  }\n\n  public static fromParsedJson(obj: JsonableSecp256k1Identity): Secp256k1KeyIdentity {\n    const [publicKeyRaw, privateKeyRaw] = obj;\n    return new Secp256k1KeyIdentity(\n      Secp256k1PublicKey.fromRaw(fromHexString(publicKeyRaw)),\n      fromHexString(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Secp256k1KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      }\n      throw new Error('Deserialization error: JSON must have at least 2 items.');\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param {ArrayBuffer} publicKey\n   * @param {ArrayBuffer} privateKey\n   * @returns {Secp256k1KeyIdentity}\n   */\n  public static fromKeyPair(publicKey: ArrayBuffer, privateKey: ArrayBuffer): Secp256k1KeyIdentity {\n    return new Secp256k1KeyIdentity(Secp256k1PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  /**\n   * generates an identity from an existing secret key, and is the correct method to generate an identity from a seed phrase. Please ensure you protect the user's private key.\n   * @param {ArrayBuffer} secretKey\n   * @returns {Secp256k1KeyIdentity}\n   */\n  public static fromSecretKey(secretKey: ArrayBuffer): Secp256k1KeyIdentity {\n    const publicKey = Secp256k1.publicKeyCreate(new Uint8Array(secretKey), false);\n    const identity = Secp256k1KeyIdentity.fromKeyPair(publicKey, new Uint8Array(secretKey));\n    return identity;\n  }\n\n  /**\n   * Generates an identity from a seed phrase. Use carefully - seed phrases should only be used in secure contexts, and you should avoid having users copying and pasting seed phrases as much as possible.\n   * @param {string | string[]} seedPhrase - either an array of words or a string of words separated by spaces.\n   * @param password - optional password to be used by bip39\n   * @returns Secp256k1KeyIdentity\n   */\n  public static fromSeedPhrase(\n    seedPhrase: string | string[],\n    password?: string | undefined,\n  ): Secp256k1KeyIdentity {\n    // Convert to string for convenience\n    const phrase = Array.isArray(seedPhrase) ? seedPhrase.join(' ') : seedPhrase;\n    // Warn if provided phrase is not conventional\n    if (phrase.split(' ').length < 12 || phrase.split(' ').length > 24) {\n      console.warn(\n        'Warning - an unusually formatted seed phrase has been provided. Decoding may not work as expected',\n      );\n    }\n\n    const seed = mnemonicToSeedSync(phrase, password);\n    const root = hdkey.fromMasterSeed(seed);\n    const addrnode = root.derive(\"m/44'/223'/0'/0/0\");\n\n    return Secp256k1KeyIdentity.fromSecretKey(addrnode.privateKey);\n  }\n\n  protected _publicKey: Secp256k1PublicKey;\n\n  protected constructor(publicKey: Secp256k1PublicKey, protected _privateKey: ArrayBuffer) {\n    super();\n    this._publicKey = publicKey;\n  }\n\n  /**\n   * Serialize this key to JSON-serializable object.\n   * @returns {JsonableSecp256k1Identity}\n   */\n  public toJSON(): JsonableSecp256k1Identity {\n    return [toHexString(this._publicKey.toRaw()), toHexString(this._privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   * @returns {KeyPair}\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this._privateKey,\n      publicKey: this._publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   * @returns {Secp256k1PublicKey}\n   */\n  public getPublicKey(): Secp256k1PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const hash = sha256.create();\n    hash.update(challenge);\n    const signature = Secp256k1.ecdsaSign(\n      new Uint8Array(hash.digest()),\n      new Uint8Array(this._privateKey),\n    ).signature.buffer;\n    return signature as Signature;\n  }\n}\n\nexport default Secp256k1KeyIdentity;\n"]}